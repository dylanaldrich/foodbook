{"version":3,"file":"focus-trap.umd.min.js","sources":["../index.js"],"sourcesContent":["import { tabbable, isFocusable } from 'tabbable';\n\nvar activeFocusDelay;\n\nvar activeFocusTraps = (function () {\n  var trapQueue = [];\n  return {\n    activateTrap: function (trap) {\n      if (trapQueue.length > 0) {\n        var activeTrap = trapQueue[trapQueue.length - 1];\n        if (activeTrap !== trap) {\n          activeTrap.pause();\n        }\n      }\n\n      var trapIndex = trapQueue.indexOf(trap);\n      if (trapIndex === -1) {\n        trapQueue.push(trap);\n      } else {\n        // move this existing trap to the front of the queue\n        trapQueue.splice(trapIndex, 1);\n        trapQueue.push(trap);\n      }\n    },\n\n    deactivateTrap: function (trap) {\n      var trapIndex = trapQueue.indexOf(trap);\n      if (trapIndex !== -1) {\n        trapQueue.splice(trapIndex, 1);\n      }\n\n      if (trapQueue.length > 0) {\n        trapQueue[trapQueue.length - 1].unpause();\n      }\n    },\n  };\n})();\n\nfunction createFocusTrap(element, userOptions) {\n  var doc = document;\n  var container =\n    typeof element === 'string' ? doc.querySelector(element) : element;\n\n  var config = {\n    returnFocusOnDeactivate: true,\n    escapeDeactivates: true,\n    delayInitialFocus: true,\n    ...userOptions,\n  };\n\n  var state = {\n    firstTabbableNode: null,\n    lastTabbableNode: null,\n    nodeFocusedBeforeActivation: null,\n    mostRecentlyFocusedNode: null,\n    active: false,\n    paused: false,\n  };\n\n  var trap = {\n    activate: activate,\n    deactivate: deactivate,\n    pause: pause,\n    unpause: unpause,\n  };\n\n  return trap;\n\n  function activate(activateOptions) {\n    if (state.active) return;\n\n    updateTabbableNodes();\n\n    state.active = true;\n    state.paused = false;\n    state.nodeFocusedBeforeActivation = doc.activeElement;\n\n    var onActivate =\n      activateOptions && activateOptions.onActivate\n        ? activateOptions.onActivate\n        : config.onActivate;\n    if (onActivate) {\n      onActivate();\n    }\n\n    addListeners();\n    return trap;\n  }\n\n  function deactivate(deactivateOptions) {\n    if (!state.active) return;\n\n    clearTimeout(activeFocusDelay);\n\n    removeListeners();\n    state.active = false;\n    state.paused = false;\n\n    activeFocusTraps.deactivateTrap(trap);\n\n    var onDeactivate =\n      deactivateOptions && deactivateOptions.onDeactivate !== undefined\n        ? deactivateOptions.onDeactivate\n        : config.onDeactivate;\n    if (onDeactivate) {\n      onDeactivate();\n    }\n\n    var returnFocus =\n      deactivateOptions && deactivateOptions.returnFocus !== undefined\n        ? deactivateOptions.returnFocus\n        : config.returnFocusOnDeactivate;\n    if (returnFocus) {\n      delay(function () {\n        tryFocus(getReturnFocusNode(state.nodeFocusedBeforeActivation));\n      });\n    }\n\n    return trap;\n  }\n\n  function pause() {\n    if (state.paused || !state.active) return;\n    state.paused = true;\n    removeListeners();\n  }\n\n  function unpause() {\n    if (!state.paused || !state.active) return;\n    state.paused = false;\n    updateTabbableNodes();\n    addListeners();\n  }\n\n  function addListeners() {\n    if (!state.active) return;\n\n    // There can be only one listening focus trap at a time\n    activeFocusTraps.activateTrap(trap);\n\n    // Delay ensures that the focused element doesn't capture the event\n    // that caused the focus trap activation.\n    activeFocusDelay = config.delayInitialFocus\n      ? delay(function () {\n          tryFocus(getInitialFocusNode());\n        })\n      : tryFocus(getInitialFocusNode());\n\n    doc.addEventListener('focusin', checkFocusIn, true);\n    doc.addEventListener('mousedown', checkPointerDown, {\n      capture: true,\n      passive: false,\n    });\n    doc.addEventListener('touchstart', checkPointerDown, {\n      capture: true,\n      passive: false,\n    });\n    doc.addEventListener('click', checkClick, {\n      capture: true,\n      passive: false,\n    });\n    doc.addEventListener('keydown', checkKey, {\n      capture: true,\n      passive: false,\n    });\n\n    return trap;\n  }\n\n  function removeListeners() {\n    if (!state.active) return;\n\n    doc.removeEventListener('focusin', checkFocusIn, true);\n    doc.removeEventListener('mousedown', checkPointerDown, true);\n    doc.removeEventListener('touchstart', checkPointerDown, true);\n    doc.removeEventListener('click', checkClick, true);\n    doc.removeEventListener('keydown', checkKey, true);\n\n    return trap;\n  }\n\n  function getNodeForOption(optionName) {\n    var optionValue = config[optionName];\n    var node = optionValue;\n    if (!optionValue) {\n      return null;\n    }\n    if (typeof optionValue === 'string') {\n      node = doc.querySelector(optionValue);\n      if (!node) {\n        throw new Error('`' + optionName + '` refers to no known node');\n      }\n    }\n    if (typeof optionValue === 'function') {\n      node = optionValue();\n      if (!node) {\n        throw new Error('`' + optionName + '` did not return a node');\n      }\n    }\n    return node;\n  }\n\n  function getInitialFocusNode() {\n    var node;\n    if (getNodeForOption('initialFocus') !== null) {\n      node = getNodeForOption('initialFocus');\n    } else if (container.contains(doc.activeElement)) {\n      node = doc.activeElement;\n    } else {\n      node = state.firstTabbableNode || getNodeForOption('fallbackFocus');\n    }\n\n    if (!node) {\n      throw new Error(\n        'Your focus-trap needs to have at least one focusable element'\n      );\n    }\n\n    return node;\n  }\n\n  function getReturnFocusNode(previousActiveElement) {\n    var node = getNodeForOption('setReturnFocus');\n    return node ? node : previousActiveElement;\n  }\n\n  // This needs to be done on mousedown and touchstart instead of click\n  // so that it precedes the focus event.\n  function checkPointerDown(e) {\n    if (container.contains(e.target)) {\n      // allow the click since it ocurred inside the trap\n      return;\n    }\n\n    if (config.clickOutsideDeactivates) {\n      // immediately deactivate the trap\n      deactivate({\n        // if, on deactivation, we should return focus to the node originally-focused\n        //  when the trap was activated (or the configured `setReturnFocus` node),\n        //  then assume it's also OK to return focus to the outside node that was\n        //  just clicked, causing deactivation, as long as that node is focusable;\n        //  if it isn't focusable, then return focus to the original node focused\n        //  on activation (or the configured `setReturnFocus` node)\n        // NOTE: by setting `returnFocus: false`, deactivate() will do nothing,\n        //  which will result in the outside click setting focus to the node\n        //  that was clicked, whether it's focusable or not; by setting\n        //  `returnFocus: true`, we'll attempt to re-focus the node originally-focused\n        //  on activation (or the configured `setReturnFocus` node)\n        returnFocus: config.returnFocusOnDeactivate && !isFocusable(e.target),\n      });\n      return;\n    }\n\n    // This is needed for mobile devices.\n    // (If we'll only let `click` events through,\n    // then on mobile they will be blocked anyways if `touchstart` is blocked.)\n    if (\n      config.allowOutsideClick &&\n      (typeof config.allowOutsideClick === 'boolean'\n        ? config.allowOutsideClick\n        : config.allowOutsideClick(e))\n    ) {\n      // allow the click outside the trap to take place\n      return;\n    }\n\n    // otherwise, prevent the click\n    e.preventDefault();\n  }\n\n  // In case focus escapes the trap for some strange reason, pull it back in.\n  function checkFocusIn(e) {\n    // In Firefox when you Tab out of an iframe the Document is briefly focused.\n    if (container.contains(e.target) || e.target instanceof Document) {\n      return;\n    }\n    e.stopImmediatePropagation();\n    tryFocus(state.mostRecentlyFocusedNode || getInitialFocusNode());\n  }\n\n  function checkKey(e) {\n    if (config.escapeDeactivates !== false && isEscapeEvent(e)) {\n      e.preventDefault();\n      deactivate();\n      return;\n    }\n    if (isTabEvent(e)) {\n      checkTab(e);\n      return;\n    }\n  }\n\n  // Hijack Tab events on the first and last focusable nodes of the trap,\n  // in order to prevent focus from escaping. If it escapes for even a\n  // moment it can end up scrolling the page and causing confusion so we\n  // kind of need to capture the action at the keydown phase.\n  function checkTab(e) {\n    updateTabbableNodes();\n    if (e.shiftKey && e.target === state.firstTabbableNode) {\n      e.preventDefault();\n      tryFocus(state.lastTabbableNode);\n      return;\n    }\n    if (!e.shiftKey && e.target === state.lastTabbableNode) {\n      e.preventDefault();\n      tryFocus(state.firstTabbableNode);\n      return;\n    }\n  }\n\n  function checkClick(e) {\n    if (config.clickOutsideDeactivates) return;\n    if (container.contains(e.target)) return;\n    if (\n      config.allowOutsideClick &&\n      (typeof config.allowOutsideClick === 'boolean'\n        ? config.allowOutsideClick\n        : config.allowOutsideClick(e))\n    ) {\n      return;\n    }\n    e.preventDefault();\n    e.stopImmediatePropagation();\n  }\n\n  function updateTabbableNodes() {\n    var tabbableNodes = tabbable(container);\n    state.firstTabbableNode = tabbableNodes[0] || getInitialFocusNode();\n    state.lastTabbableNode =\n      tabbableNodes[tabbableNodes.length - 1] || getInitialFocusNode();\n  }\n\n  function tryFocus(node) {\n    if (node === doc.activeElement) return;\n    if (!node || !node.focus) {\n      tryFocus(getInitialFocusNode());\n      return;\n    }\n    node.focus({ preventScroll: !!config.preventScroll });\n    state.mostRecentlyFocusedNode = node;\n    if (isSelectableInput(node)) {\n      node.select();\n    }\n  }\n}\n\nfunction isSelectableInput(node) {\n  return (\n    node.tagName &&\n    node.tagName.toLowerCase() === 'input' &&\n    typeof node.select === 'function'\n  );\n}\n\nfunction isEscapeEvent(e) {\n  return e.key === 'Escape' || e.key === 'Esc' || e.keyCode === 27;\n}\n\nfunction isTabEvent(e) {\n  return e.key === 'Tab' || e.keyCode === 9;\n}\n\nfunction delay(fn) {\n  return setTimeout(fn, 0);\n}\n\nexport { createFocusTrap };\n"],"names":["activeFocusDelay","trapQueue","activeFocusTraps","activateTrap","trap","length","activeTrap","pause","trapIndex","indexOf","splice","push","deactivateTrap","unpause","delay","fn","setTimeout","element","userOptions","doc","document","container","querySelector","config","returnFocusOnDeactivate","escapeDeactivates","delayInitialFocus","state","firstTabbableNode","lastTabbableNode","nodeFocusedBeforeActivation","mostRecentlyFocusedNode","active","paused","activate","activateOptions","updateTabbableNodes","activeElement","onActivate","addListeners","deactivate","removeListeners","deactivateOptions","clearTimeout","onDeactivate","undefined","returnFocus","previousActiveElement","tryFocus","getNodeForOption","getInitialFocusNode","addEventListener","checkFocusIn","checkPointerDown","capture","passive","checkClick","checkKey","removeEventListener","optionName","optionValue","node","Error","contains","e","target","clickOutsideDeactivates","isFocusable","allowOutsideClick","preventDefault","Document","stopImmediatePropagation","key","keyCode","isEscapeEvent","isTabEvent","shiftKey","checkTab","tabbableNodes","tabbable","focus","preventScroll","tagName","toLowerCase","select","isSelectableInput"],"mappings":"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"}